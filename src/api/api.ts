/* tslint:disable */
/* eslint-disable */
/**
 * spaceship
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ActualPriceParams
 */
export interface ActualPriceParams {
    /**
     * 
     * @type {Array<OrderProduct>}
     * @memberof ActualPriceParams
     */
    'products': Array<OrderProduct>;
    /**
     * 
     * @type {OrderDelivery}
     * @memberof ActualPriceParams
     */
    'delivery': OrderDelivery;
    /**
     * 
     * @type {string}
     * @memberof ActualPriceParams
     */
    'promocode'?: string;
}
/**
 * 
 * @export
 * @interface AdditionalProduct
 */
export interface AdditionalProduct {
    /**
     * 
     * @type {string}
     * @memberof AdditionalProduct
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AdditionalProduct
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof AdditionalProduct
     */
    'price': number;
}
/**
 * 
 * @export
 * @interface AddressPickup
 */
export interface AddressPickup {
    /**
     * 
     * @type {string}
     * @memberof AddressPickup
     */
    'id': string;
    /**
     * 
     * @type {Location}
     * @memberof AddressPickup
     */
    'location': Location;
    /**
     * 
     * @type {string}
     * @memberof AddressPickup
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof AddressPickup
     */
    'badge'?: string;
}
/**
 * 
 * @export
 * @interface AddressSuggest
 */
export interface AddressSuggest {
    /**
     * 
     * @type {string}
     * @memberof AddressSuggest
     */
    'address': string;
    /**
     * 
     * @type {Location}
     * @memberof AddressSuggest
     */
    'location': Location;
}
/**
 * 
 * @export
 * @interface AddressSuggestRequest
 */
export interface AddressSuggestRequest {
    /**
     * 
     * @type {string}
     * @memberof AddressSuggestRequest
     */
    'address': string;
}
/**
 * 
 * @export
 * @interface AuthCodeVerifyRequest
 */
export interface AuthCodeVerifyRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthCodeVerifyRequest
     */
    'phoneNumber': string;
    /**
     * 
     * @type {string}
     * @memberof AuthCodeVerifyRequest
     */
    'code': string;
}
/**
 * 
 * @export
 * @interface AuthRefreshTokenRequest
 */
export interface AuthRefreshTokenRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthRefreshTokenRequest
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface AuthSendCodeRequest
 */
export interface AuthSendCodeRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthSendCodeRequest
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface AuthSendCodeResponse
 */
export interface AuthSendCodeResponse {
    /**
     * 
     * @type {string}
     * @memberof AuthSendCodeResponse
     */
    'expirationDateTime': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum AuthSocialProviderEnum {
    VK = 'vk',
    FB = 'fb'
}

/**
 * 
 * @export
 * @interface AuthSocialRequest
 */
export interface AuthSocialRequest {
    /**
     * 
     * @type {string}
     * @memberof AuthSocialRequest
     */
    'token': string;
    /**
     * 
     * @type {AuthSocialProviderEnum}
     * @memberof AuthSocialRequest
     */
    'provider': AuthSocialProviderEnum;
}
/**
 * 
 * @export
 * @interface AuthToken
 */
export interface AuthToken {
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    'access': string;
    /**
     * 
     * @type {string}
     * @memberof AuthToken
     */
    'refresh': string;
}
/**
 * 
 * @export
 * @interface CreateUserAddressRequest
 */
export interface CreateUserAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    'entrance'?: string;
    /**
     * 
     * @type {number}
     * @memberof CreateUserAddressRequest
     */
    'floor'?: number;
    /**
     * 
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    'apartmentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateUserAddressRequest
     */
    'courierComment'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum DeliveryTypeEnum {
    COURIER = 'courier',
    SELF = 'self'
}

/**
 * 
 * @export
 * @interface FoodEnergy
 */
export interface FoodEnergy {
    /**
     * жиры
     * @type {number}
     * @memberof FoodEnergy
     */
    'fat'?: number;
    /**
     * белки
     * @type {number}
     * @memberof FoodEnergy
     */
    'proteins'?: number;
    /**
     * углеводы
     * @type {number}
     * @memberof FoodEnergy
     */
    'carbohydrates'?: number;
    /**
     * калории
     * @type {number}
     * @memberof FoodEnergy
     */
    'calories'?: number;
}
/**
 * 
 * @export
 * @interface FoodInfo
 */
export interface FoodInfo {
    /**
     * 
     * @type {Array<string>}
     * @memberof FoodInfo
     */
    'allergens'?: Array<string>;
    /**
     * 
     * @type {FoodEnergy}
     * @memberof FoodInfo
     */
    'foodEnergy'?: FoodEnergy;
    /**
     * 
     * @type {ProductSize}
     * @memberof FoodInfo
     */
    'size'?: ProductSize;
    /**
     * 
     * @type {Array<string>}
     * @memberof FoodInfo
     */
    'ingredients'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GetCurrentOrderResponse
 */
export interface GetCurrentOrderResponse {
    /**
     * 
     * @type {string}
     * @memberof GetCurrentOrderResponse
     */
    'id': string;
    /**
     * 
     * @type {OrderStatus}
     * @memberof GetCurrentOrderResponse
     */
    'status': OrderStatus;
    /**
     * 
     * @type {Array<UserOrderProductDetail>}
     * @memberof GetCurrentOrderResponse
     */
    'products': Array<UserOrderProductDetail>;
    /**
     * 
     * @type {string}
     * @memberof GetCurrentOrderResponse
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof GetCurrentOrderResponse
     */
    'timeLeft'?: string;
}
/**
 * 
 * @export
 * @interface GetProductCategoryDetailRequest
 */
export interface GetProductCategoryDetailRequest {
    /**
     * 
     * @type {SearchForRelativeParams}
     * @memberof GetProductCategoryDetailRequest
     */
    'searchForRelativeParams': SearchForRelativeParams;
    /**
     * 
     * @type {Array<string>}
     * @memberof GetProductCategoryDetailRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface InlineObject
 */
export interface InlineObject {
    /**
     * 
     * @type {string}
     * @memberof InlineObject
     */
    'productId'?: string;
    /**
     * 
     * @type {SearchForRelativeParams}
     * @memberof InlineObject
     */
    'searchForRelativeParams': SearchForRelativeParams;
}
/**
 * 
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'longitude': number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'latitude': number;
}
/**
 * @type OrderDelivery
 * @export
 */
export type OrderDelivery = AddressPickup | UserAddress;

/**
 * 
 * @export
 * @interface OrderParams
 */
export interface OrderParams {
    /**
     * 
     * @type {Array<OrderProduct>}
     * @memberof OrderParams
     */
    'products': Array<OrderProduct>;
    /**
     * 
     * @type {OrderDelivery}
     * @memberof OrderParams
     */
    'delivery': OrderDelivery;
    /**
     * 
     * @type {string}
     * @memberof OrderParams
     */
    'deliveryTime': string;
    /**
     * 
     * @type {string}
     * @memberof OrderParams
     */
    'promocode'?: string;
    /**
     * 
     * @type {string}
     * @memberof OrderParams
     */
    'paymentType': OrderParamsPaymentTypeEnum;
    /**
     * 
     * @type {string}
     * @memberof OrderParams
     */
    'emailPaymentReceipt'?: string;
}

/**
    * @export
    * @enum {string}
    */
export enum OrderParamsPaymentTypeEnum {
    CASH = 'cash',
    BY_CARD_TO_COURIER = 'by_card_to_courier',
    BY_CARD_ONLINE = 'by_card_online'
}

/**
 * 
 * @export
 * @interface OrderProduct
 */
export interface OrderProduct {
    /**
     * 
     * @type {string}
     * @memberof OrderProduct
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof OrderProduct
     */
    'quantity': number;
    /**
     * 
     * @type {Array<AdditionalProduct>}
     * @memberof OrderProduct
     */
    'additionalProducts'?: Array<AdditionalProduct>;
    /**
     * 
     * @type {Array<string>}
     * @memberof OrderProduct
     */
    'removeIngredients'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof OrderProduct
     */
    'isGift'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum OrderStatus {
    ORDERING_PROCESS = 'ordering_process',
    COOKING = 'cooking',
    PLACE_AN_ORDER = 'place_an_order',
    SHIPING = 'shiping',
    DONE = 'done'
}

/**
 * 
 * @export
 * @interface ProductCategoryDetail
 */
export interface ProductCategoryDetail {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDetail
     */
    'title': string;
    /**
     * 
     * @type {Array<ProductDetail>}
     * @memberof ProductCategoryDetail
     */
    'products': Array<ProductDetail>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductCategoryDetail
     */
    'isAvailable': boolean;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryDetail
     */
    'availableDateTime'?: string;
}
/**
 * 
 * @export
 * @interface ProductCategoryPreview
 */
export interface ProductCategoryPreview {
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPreview
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductCategoryPreview
     */
    'title': string;
    /**
     * 
     * @type {Array<ProductDetail>}
     * @memberof ProductCategoryPreview
     */
    'products': Array<ProductDetail>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductCategoryPreview
     */
    'isAvailable': boolean;
    /**
     * Время активациии категории
     * @type {string}
     * @memberof ProductCategoryPreview
     */
    'availableDateTime'?: string;
}
/**
 * 
 * @export
 * @interface ProductDetail
 */
export interface ProductDetail {
    /**
     * 
     * @type {string}
     * @memberof ProductDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetail
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ProductDetail
     */
    'price': number;
    /**
     * 
     * @type {string}
     * @memberof ProductDetail
     */
    'image': string;
    /**
     * 
     * @type {string}
     * @memberof ProductDetail
     */
    'description'?: string;
    /**
     * 
     * @type {FoodInfo}
     * @memberof ProductDetail
     */
    'foodInfo': FoodInfo;
    /**
     * 
     * @type {Array<AdditionalProduct>}
     * @memberof ProductDetail
     */
    'additionalProducts'?: Array<AdditionalProduct>;
    /**
     * 
     * @type {boolean}
     * @memberof ProductDetail
     */
    'isAvailable'?: boolean;
}
/**
 * 
 * @export
 * @interface ProductPromo
 */
export interface ProductPromo {
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'description'?: string;
    /**
     * 
     * @type {Array<ProductDetail>}
     * @memberof ProductPromo
     */
    'products': Array<ProductDetail>;
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'startDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'expirationDateTime'?: string;
    /**
     * 
     * @type {string}
     * @memberof ProductPromo
     */
    'image': string;
    /**
     * 
     * @type {boolean}
     * @memberof ProductPromo
     */
    'isAvailable'?: boolean;
}
/**
 * @type ProductSize
 * @export
 */
export type ProductSize = Volume | Weight;

/**
 * 
 * @export
 * @interface PushNotificationsSubscribeRequest
 */
export interface PushNotificationsSubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof PushNotificationsSubscribeRequest
     */
    'provider': PushNotificationsSubscribeRequestProviderEnum;
    /**
     * 
     * @type {string}
     * @memberof PushNotificationsSubscribeRequest
     */
    'token': string;
}

/**
    * @export
    * @enum {string}
    */
export enum PushNotificationsSubscribeRequestProviderEnum {
    IOS = 'ios',
    ANDROID = 'android'
}

/**
 * 
 * @export
 * @interface PushNotificationsUnsubscribeRequest
 */
export interface PushNotificationsUnsubscribeRequest {
    /**
     * 
     * @type {string}
     * @memberof PushNotificationsUnsubscribeRequest
     */
    'token': string;
}
/**
 * 
 * @export
 * @interface SearchForCourierDelivery
 */
export interface SearchForCourierDelivery {
    /**
     * 
     * @type {Location}
     * @memberof SearchForCourierDelivery
     */
    'courierAddressLocation': Location;
}
/**
 * 
 * @export
 * @interface SearchForPickupDelivery
 */
export interface SearchForPickupDelivery {
    /**
     * 
     * @type {string}
     * @memberof SearchForPickupDelivery
     */
    'pickupAddressId': string;
}
/**
 * @type SearchForRelativeParams
 * @export
 */
export type SearchForRelativeParams = SearchForCourierDelivery | SearchForPickupDelivery;

/**
 * 
 * @export
 * @interface UpdateUserAddressRequest
 */
export interface UpdateUserAddressRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    'address'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    'entrance'?: string;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserAddressRequest
     */
    'floor'?: number;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    'apartmentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserAddressRequest
     */
    'courierComment'?: string;
}
/**
 * 
 * @export
 * @interface UpdateUserPreferencesRequest
 */
export interface UpdateUserPreferencesRequest {
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserPreferencesRequest
     */
    'spicy'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserPreferencesRequest
     */
    'vegan'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserPreferencesRequest
     */
    'exclude'?: Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UpdateUserPreferencesRequest
     */
    'allergies'?: Array<string>;
}
/**
 * 
 * @export
 * @interface UpdateUserRequest
 */
export interface UpdateUserRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'birthday'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserRequest
     */
    'email'?: string;
    /**
     * 
     * @type {UserGenderEnum}
     * @memberof UpdateUserRequest
     */
    'gender'?: UserGenderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserRequest
     */
    'hasKids'?: boolean;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'birthday'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {UserGenderEnum}
     * @memberof User
     */
    'gender'?: UserGenderEnum;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'hasKids'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'phoneNumber': string;
}
/**
 * 
 * @export
 * @interface UserAddress
 */
export interface UserAddress {
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'address': string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'entrance'?: string;
    /**
     * 
     * @type {number}
     * @memberof UserAddress
     */
    'floor'?: number;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'apartmentNumber'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'courierComment'?: string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserAddress
     */
    'updatedAt': string;
    /**
     * 
     * @type {Location}
     * @memberof UserAddress
     */
    'location': Location;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum UserGenderEnum {
    MAN = 'man',
    WOMEN = 'women'
}

/**
 * 
 * @export
 * @interface UserOrder
 */
export interface UserOrder {
    /**
     * 
     * @type {string}
     * @memberof UserOrder
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof UserOrder
     */
    'price': number;
    /**
     * 
     * @type {Array<UserOrderProductDetail>}
     * @memberof UserOrder
     */
    'products': Array<UserOrderProductDetail>;
    /**
     * 
     * @type {string}
     * @memberof UserOrder
     */
    'createdAt': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrder
     */
    'dateFinish': string;
    /**
     * 
     * @type {DeliveryTypeEnum}
     * @memberof UserOrder
     */
    'deliveryType': DeliveryTypeEnum;
}
/**
 * 
 * @export
 * @interface UserOrderProductDetail
 */
export interface UserOrderProductDetail {
    /**
     * 
     * @type {string}
     * @memberof UserOrderProductDetail
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrderProductDetail
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UserOrderProductDetail
     */
    'image': string;
    /**
     * 
     * @type {number}
     * @memberof UserOrderProductDetail
     */
    'quantity': number;
    /**
     * 
     * @type {number}
     * @memberof UserOrderProductDetail
     */
    'price': number;
    /**
     * 
     * @type {number}
     * @memberof UserOrderProductDetail
     */
    'amount': number;
}
/**
 * 
 * @export
 * @interface UserPreferences
 */
export interface UserPreferences {
    /**
     * 
     * @type {boolean}
     * @memberof UserPreferences
     */
    'spicy': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof UserPreferences
     */
    'vegan': boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPreferences
     */
    'exclude': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof UserPreferences
     */
    'allergies': Array<string>;
}
/**
 * 
 * @export
 * @interface Volume
 */
export interface Volume {
    /**
     * 
     * @type {number}
     * @memberof Volume
     */
    'value': number;
    /**
     * 
     * @type {VolumeUnitEnum}
     * @memberof Volume
     */
    'unit': VolumeUnitEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum VolumeUnitEnum {
    L = 'l',
    ML = 'ml'
}

/**
 * 
 * @export
 * @interface Weight
 */
export interface Weight {
    /**
     * 
     * @type {number}
     * @memberof Weight
     */
    'value': number;
    /**
     * 
     * @type {WeightUnitEnum}
     * @memberof Weight
     */
    'unit': WeightUnitEnum;
}
/**
 * 
 * @export
 * @enum {string}
 */

export enum WeightUnitEnum {
    G = 'g',
    KG = 'kg'
}


/**
 * AddressApi - axios parameter creator
 * @export
 */
export const AddressApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Address suggest
         * @param {AddressSuggestRequest} [addressSuggestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressSuggest: async (addressSuggestRequest?: AddressSuggestRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address/suggest`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(addressSuggestRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pickup addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressPickupList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/address/pickup`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AddressApi - functional programming interface
 * @export
 */
export const AddressApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AddressApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Address suggest
         * @param {AddressSuggestRequest} [addressSuggestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addressSuggest(addressSuggestRequest?: AddressSuggestRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressSuggest>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addressSuggest(addressSuggestRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pickup addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressPickupList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressPickup>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressPickupList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AddressApi - factory interface
 * @export
 */
export const AddressApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AddressApiFp(configuration)
    return {
        /**
         * 
         * @summary Address suggest
         * @param {AddressSuggestRequest} [addressSuggestRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addressSuggest(addressSuggestRequest?: AddressSuggestRequest, options?: any): AxiosPromise<Array<AddressSuggest>> {
            return localVarFp.addressSuggest(addressSuggestRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pickup addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressPickupList(options?: any): AxiosPromise<Array<AddressPickup>> {
            return localVarFp.getAddressPickupList(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AddressApi - object-oriented interface
 * @export
 * @class AddressApi
 * @extends {BaseAPI}
 */
export class AddressApi extends BaseAPI {
    /**
     * 
     * @summary Address suggest
     * @param {AddressSuggestRequest} [addressSuggestRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public addressSuggest(addressSuggestRequest?: AddressSuggestRequest, options?: AxiosRequestConfig) {
        return AddressApiFp(this.configuration).addressSuggest(addressSuggestRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pickup addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AddressApi
     */
    public getAddressPickupList(options?: AxiosRequestConfig) {
        return AddressApiFp(this.configuration).getAddressPickupList(options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * AuthApi - axios parameter creator
 * @export
 */
export const AuthApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Проверка кода отправленного на телефон
         * @summary Auth Code Verify
         * @param {AuthCodeVerifyRequest} [authCodeVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCodeVerify: async (authCodeVerifyRequest?: AuthCodeVerifyRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/code-verify`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authCodeVerifyRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Обновление токена после невалидности основного
         * @summary Auth Refresh Token
         * @param {AuthRefreshTokenRequest} [authRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshToken: async (authRefreshTokenRequest?: AuthRefreshTokenRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authRefreshTokenRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Отправка кода подтверждения на номер телефона
         * @summary Auth Send Code
         * @param {AuthSendCodeRequest} [authSendCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendCode: async (authSendCodeRequest?: AuthSendCodeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/send-code`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSendCodeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Авторизация через социальные сервисы. Для авторизации потребуется указать тип провайдера, например vk и прислать токен, который отдает тот или иной сервис
         * @summary Auth Social
         * @param {AuthSocialRequest} [authSocialRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSocial: async (authSocialRequest?: AuthSocialRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/social`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(authSocialRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Push Notifications Unsubscribe
         * @param {PushNotificationsUnsubscribeRequest} [pushNotificationsUnsubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthPushNotificationsUnsubscribe: async (pushNotificationsUnsubscribeRequest?: PushNotificationsUnsubscribeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/push-notifications-unsubscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushNotificationsUnsubscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Push Notifications Subscribe
         * @param {PushNotificationsSubscribeRequest} [pushNotificationsSubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsSubscribe: async (pushNotificationsSubscribeRequest?: PushNotificationsSubscribeRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/auth/push-notifications-subscribe`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pushNotificationsSubscribeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AuthApi - functional programming interface
 * @export
 */
export const AuthApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AuthApiAxiosParamCreator(configuration)
    return {
        /**
         * Проверка кода отправленного на телефон
         * @summary Auth Code Verify
         * @param {AuthCodeVerifyRequest} [authCodeVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authCodeVerify(authCodeVerifyRequest?: AuthCodeVerifyRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authCodeVerify(authCodeVerifyRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Обновление токена после невалидности основного
         * @summary Auth Refresh Token
         * @param {AuthRefreshTokenRequest} [authRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authRefreshToken(authRefreshTokenRequest?: AuthRefreshTokenRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authRefreshToken(authRefreshTokenRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Отправка кода подтверждения на номер телефона
         * @summary Auth Send Code
         * @param {AuthSendCodeRequest} [authSendCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSendCode(authSendCodeRequest?: AuthSendCodeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthSendCodeResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSendCode(authSendCodeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Авторизация через социальные сервисы. Для авторизации потребуется указать тип провайдера, например vk и прислать токен, который отдает тот или иной сервис
         * @summary Auth Social
         * @param {AuthSocialRequest} [authSocialRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authSocial(authSocialRequest?: AuthSocialRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AuthToken>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authSocial(authSocialRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Push Notifications Unsubscribe
         * @param {PushNotificationsUnsubscribeRequest} [pushNotificationsUnsubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest?: PushNotificationsUnsubscribeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Push Notifications Subscribe
         * @param {PushNotificationsSubscribeRequest} [pushNotificationsSubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pushNotificationsSubscribe(pushNotificationsSubscribeRequest?: PushNotificationsSubscribeRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pushNotificationsSubscribe(pushNotificationsSubscribeRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * AuthApi - factory interface
 * @export
 */
export const AuthApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AuthApiFp(configuration)
    return {
        /**
         * Проверка кода отправленного на телефон
         * @summary Auth Code Verify
         * @param {AuthCodeVerifyRequest} [authCodeVerifyRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authCodeVerify(authCodeVerifyRequest?: AuthCodeVerifyRequest, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.authCodeVerify(authCodeVerifyRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Обновление токена после невалидности основного
         * @summary Auth Refresh Token
         * @param {AuthRefreshTokenRequest} [authRefreshTokenRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authRefreshToken(authRefreshTokenRequest?: AuthRefreshTokenRequest, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.authRefreshToken(authRefreshTokenRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Отправка кода подтверждения на номер телефона
         * @summary Auth Send Code
         * @param {AuthSendCodeRequest} [authSendCodeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSendCode(authSendCodeRequest?: AuthSendCodeRequest, options?: any): AxiosPromise<AuthSendCodeResponse> {
            return localVarFp.authSendCode(authSendCodeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * Авторизация через социальные сервисы. Для авторизации потребуется указать тип провайдера, например vk и прислать токен, который отдает тот или иной сервис
         * @summary Auth Social
         * @param {AuthSocialRequest} [authSocialRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authSocial(authSocialRequest?: AuthSocialRequest, options?: any): AxiosPromise<AuthToken> {
            return localVarFp.authSocial(authSocialRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Push Notifications Unsubscribe
         * @param {PushNotificationsUnsubscribeRequest} [pushNotificationsUnsubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest?: PushNotificationsUnsubscribeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Push Notifications Subscribe
         * @param {PushNotificationsSubscribeRequest} [pushNotificationsSubscribeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pushNotificationsSubscribe(pushNotificationsSubscribeRequest?: PushNotificationsSubscribeRequest, options?: any): AxiosPromise<void> {
            return localVarFp.pushNotificationsSubscribe(pushNotificationsSubscribeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AuthApi - object-oriented interface
 * @export
 * @class AuthApi
 * @extends {BaseAPI}
 */
export class AuthApi extends BaseAPI {
    /**
     * Проверка кода отправленного на телефон
     * @summary Auth Code Verify
     * @param {AuthCodeVerifyRequest} [authCodeVerifyRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authCodeVerify(authCodeVerifyRequest?: AuthCodeVerifyRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authCodeVerify(authCodeVerifyRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Обновление токена после невалидности основного
     * @summary Auth Refresh Token
     * @param {AuthRefreshTokenRequest} [authRefreshTokenRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authRefreshToken(authRefreshTokenRequest?: AuthRefreshTokenRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authRefreshToken(authRefreshTokenRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Отправка кода подтверждения на номер телефона
     * @summary Auth Send Code
     * @param {AuthSendCodeRequest} [authSendCodeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSendCode(authSendCodeRequest?: AuthSendCodeRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSendCode(authSendCodeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Авторизация через социальные сервисы. Для авторизации потребуется указать тип провайдера, например vk и прислать токен, который отдает тот или иной сервис
     * @summary Auth Social
     * @param {AuthSocialRequest} [authSocialRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public authSocial(authSocialRequest?: AuthSocialRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).authSocial(authSocialRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Push Notifications Unsubscribe
     * @param {PushNotificationsUnsubscribeRequest} [pushNotificationsUnsubscribeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest?: PushNotificationsUnsubscribeRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).getAuthPushNotificationsUnsubscribe(pushNotificationsUnsubscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Push Notifications Subscribe
     * @param {PushNotificationsSubscribeRequest} [pushNotificationsSubscribeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AuthApi
     */
    public pushNotificationsSubscribe(pushNotificationsSubscribeRequest?: PushNotificationsSubscribeRequest, options?: AxiosRequestConfig) {
        return AuthApiFp(this.configuration).pushNotificationsSubscribe(pushNotificationsSubscribeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrderApi - axios parameter creator
 * @export
 */
export const OrderApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create Order
         * @param {OrderParams} [orderParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder: async (orderParams?: OrderParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/create`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(orderParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Current Order Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrderInfo: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/current-order-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Order Actual Price
         * @param {ActualPriceParams} [actualPriceParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderActualPrice: async (actualPriceParams?: ActualPriceParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/order/get-actual-price`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(actualPriceParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrderApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create Order
         * @param {OrderParams} [orderParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createOrder(orderParams?: OrderParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createOrder(orderParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Current Order Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentOrderInfo(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCurrentOrderResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentOrderInfo(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Order Actual Price
         * @param {ActualPriceParams} [actualPriceParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrderActualPrice(actualPriceParams?: ActualPriceParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrderActualPrice(actualPriceParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrderApiFp(configuration)
    return {
        /**
         * 
         * @summary Create Order
         * @param {OrderParams} [orderParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createOrder(orderParams?: OrderParams, options?: any): AxiosPromise<void> {
            return localVarFp.createOrder(orderParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Current Order Info
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentOrderInfo(options?: any): AxiosPromise<GetCurrentOrderResponse> {
            return localVarFp.getCurrentOrderInfo(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Order Actual Price
         * @param {ActualPriceParams} [actualPriceParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderActualPrice(actualPriceParams?: ActualPriceParams, options?: any): AxiosPromise<number> {
            return localVarFp.getOrderActualPrice(actualPriceParams, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * 
     * @summary Create Order
     * @param {OrderParams} [orderParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public createOrder(orderParams?: OrderParams, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).createOrder(orderParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Current Order Info
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getCurrentOrderInfo(options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getCurrentOrderInfo(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Order Actual Price
     * @param {ActualPriceParams} [actualPriceParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderActualPrice(actualPriceParams?: ActualPriceParams, options?: AxiosRequestConfig) {
        return OrderApiFp(this.configuration).getOrderActualPrice(actualPriceParams, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Get category detail
         * @param {string} categoryId 
         * @param {GetProductCategoryDetailRequest} [getProductCategoryDetailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryDetail: async (categoryId: string, getProductCategoryDetailRequest?: GetProductCategoryDetailRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'categoryId' is not null or undefined
            assertParamExists('getProductCategoryDetail', 'categoryId', categoryId)
            const localVarPath = `/products/category/{categoryId}`
                .replace(`{${"categoryId"}}`, encodeURIComponent(String(categoryId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getProductCategoryDetailRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Products Main
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryListMain: async (searchForRelativeParams?: SearchForRelativeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/main`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchForRelativeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Products Promo
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductPromoList: async (searchForRelativeParams?: SearchForRelativeParams, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products/promo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchForRelativeParams, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRecommendedList: async (inlineObject?: InlineObject, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/product/recommended`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(inlineObject, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Get category detail
         * @param {string} categoryId 
         * @param {GetProductCategoryDetailRequest} [getProductCategoryDetailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCategoryDetail(categoryId: string, getProductCategoryDetailRequest?: GetProductCategoryDetailRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductCategoryDetail>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCategoryDetail(categoryId, getProductCategoryDetailRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Products Main
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductCategoryListMain(searchForRelativeParams?: SearchForRelativeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductCategoryPreview>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductCategoryListMain(searchForRelativeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Products Promo
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductPromoList(searchForRelativeParams?: SearchForRelativeParams, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductPromo>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductPromoList(searchForRelativeParams, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProductRecommendedList(inlineObject?: InlineObject, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ProductDetail>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProductRecommendedList(inlineObject, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * 
         * @summary Get category detail
         * @param {string} categoryId 
         * @param {GetProductCategoryDetailRequest} [getProductCategoryDetailRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryDetail(categoryId: string, getProductCategoryDetailRequest?: GetProductCategoryDetailRequest, options?: any): AxiosPromise<ProductCategoryDetail> {
            return localVarFp.getProductCategoryDetail(categoryId, getProductCategoryDetailRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Products Main
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductCategoryListMain(searchForRelativeParams?: SearchForRelativeParams, options?: any): AxiosPromise<Array<ProductCategoryPreview>> {
            return localVarFp.getProductCategoryListMain(searchForRelativeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Products Promo
         * @param {SearchForRelativeParams} [searchForRelativeParams] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductPromoList(searchForRelativeParams?: SearchForRelativeParams, options?: any): AxiosPromise<Array<ProductPromo>> {
            return localVarFp.getProductPromoList(searchForRelativeParams, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {InlineObject} [inlineObject] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProductRecommendedList(inlineObject?: InlineObject, options?: any): AxiosPromise<Array<ProductDetail>> {
            return localVarFp.getProductRecommendedList(inlineObject, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * 
     * @summary Get category detail
     * @param {string} categoryId 
     * @param {GetProductCategoryDetailRequest} [getProductCategoryDetailRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductCategoryDetail(categoryId: string, getProductCategoryDetailRequest?: GetProductCategoryDetailRequest, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductCategoryDetail(categoryId, getProductCategoryDetailRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Products Main
     * @param {SearchForRelativeParams} [searchForRelativeParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductCategoryListMain(searchForRelativeParams?: SearchForRelativeParams, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductCategoryListMain(searchForRelativeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Products Promo
     * @param {SearchForRelativeParams} [searchForRelativeParams] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductPromoList(searchForRelativeParams?: SearchForRelativeParams, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductPromoList(searchForRelativeParams, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {InlineObject} [inlineObject] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProductRecommendedList(inlineObject?: InlineObject, options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProductRecommendedList(inlineObject, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * UserApi - axios parameter creator
 * @export
 */
export const UserApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Create user address
         * @param {CreateUserAddressRequest} [createUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAddress: async (createUserAddressRequest?: CreateUserAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createUserAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddress: async (addressId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('getUserAddress', 'addressId', addressId)
            const localVarPath = `/user/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddressList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/addresses`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Order List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrderList: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary User Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Remove user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAddress: async (addressId: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('removeUserAddress', 'addressId', addressId)
            const localVarPath = `/user/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update current user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser: async (updateUserRequest?: UpdateUserRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Update user address
         * @param {string} addressId 
         * @param {UpdateUserAddressRequest} [updateUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAddress: async (addressId: string, updateUserAddressRequest?: UpdateUserAddressRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'addressId' is not null or undefined
            assertParamExists('updateUserAddress', 'addressId', addressId)
            const localVarPath = `/user/addresses/{addressId}`
                .replace(`{${"addressId"}}`, encodeURIComponent(String(addressId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserAddressRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences: async (updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/user/preferences`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PATCH', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserPreferencesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserApi - functional programming interface
 * @export
 */
export const UserApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Create user address
         * @param {CreateUserAddressRequest} [createUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createUserAddress(createUserAddressRequest?: CreateUserAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createUserAddress(createUserAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddress(addressId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddress(addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserAddressList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserAddress>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserAddressList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Order List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserOrderList(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UserOrder>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserOrderList(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary User Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPreferences(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPreferences(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Remove user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeUserAddress(addressId: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeUserAddress(addressId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update current user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUser(updateUserRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Update user address
         * @param {string} addressId 
         * @param {UpdateUserAddressRequest} [updateUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserAddress(addressId: string, updateUserAddressRequest?: UpdateUserAddressRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserAddress>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserAddress(addressId, updateUserAddressRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserPreferences(updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UserPreferences>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserPreferences(updateUserPreferencesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * UserApi - factory interface
 * @export
 */
export const UserApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserApiFp(configuration)
    return {
        /**
         * 
         * @summary Create user address
         * @param {CreateUserAddressRequest} [createUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createUserAddress(createUserAddressRequest?: CreateUserAddressRequest, options?: any): AxiosPromise<UserAddress> {
            return localVarFp.createUserAddress(createUserAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get current user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: any): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddress(addressId: string, options?: any): AxiosPromise<UserAddress> {
            return localVarFp.getUserAddress(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User addresses
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserAddressList(options?: any): AxiosPromise<Array<UserAddress>> {
            return localVarFp.getUserAddressList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Order List
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserOrderList(options?: any): AxiosPromise<Array<UserOrder>> {
            return localVarFp.getUserOrderList(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary User Preferences
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPreferences(options?: any): AxiosPromise<UserPreferences> {
            return localVarFp.getUserPreferences(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Remove user address
         * @param {string} addressId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeUserAddress(addressId: string, options?: any): AxiosPromise<void> {
            return localVarFp.removeUserAddress(addressId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update current user
         * @param {UpdateUserRequest} [updateUserRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUser(updateUserRequest?: UpdateUserRequest, options?: any): AxiosPromise<User> {
            return localVarFp.updateUser(updateUserRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Update user address
         * @param {string} addressId 
         * @param {UpdateUserAddressRequest} [updateUserAddressRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserAddress(addressId: string, updateUserAddressRequest?: UpdateUserAddressRequest, options?: any): AxiosPromise<UserAddress> {
            return localVarFp.updateUserAddress(addressId, updateUserAddressRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserPreferences(updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options?: any): AxiosPromise<UserPreferences> {
            return localVarFp.updateUserPreferences(updateUserPreferencesRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserApi - object-oriented interface
 * @export
 * @class UserApi
 * @extends {BaseAPI}
 */
export class UserApi extends BaseAPI {
    /**
     * 
     * @summary Create user address
     * @param {CreateUserAddressRequest} [createUserAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public createUserAddress(createUserAddressRequest?: CreateUserAddressRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).createUserAddress(createUserAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get current user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getCurrentUser(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get user address
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserAddress(addressId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserAddress(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User addresses
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserAddressList(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserAddressList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Order List
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserOrderList(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserOrderList(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary User Preferences
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public getUserPreferences(options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).getUserPreferences(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Remove user address
     * @param {string} addressId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public removeUserAddress(addressId: string, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).removeUserAddress(addressId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update current user
     * @param {UpdateUserRequest} [updateUserRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUser(updateUserRequest?: UpdateUserRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUser(updateUserRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Update user address
     * @param {string} addressId 
     * @param {UpdateUserAddressRequest} [updateUserAddressRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserAddress(addressId: string, updateUserAddressRequest?: UpdateUserAddressRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserAddress(addressId, updateUserAddressRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {UpdateUserPreferencesRequest} [updateUserPreferencesRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserApi
     */
    public updateUserPreferences(updateUserPreferencesRequest?: UpdateUserPreferencesRequest, options?: AxiosRequestConfig) {
        return UserApiFp(this.configuration).updateUserPreferences(updateUserPreferencesRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


